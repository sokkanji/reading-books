# 함수
### 1. 작게 만들어라
* if문 / else문 / while 문 등에 들어가는 블록은 한 줄이어야한다. 그 안에서 함수를 호출한다.
* 중첩 구조가 생길만큼 함수가 커져서는 안 된다는 뜻이다. 그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

### 2. 한 가지만 해라!
* 함수는 한 가지 일을 해야한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

### 3. 함수 당 추상화 수준은 하나로!
* 함수가 확실히 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.

**위에서 아래로 코드 읽기 : 내려가기 규칙**
* 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 
* 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 
* 즉 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

### 4. Switch문
* 각 케이스마다 함수를 리턴하는 형식으로 구현한다.

### 5. 서술적인 이름을 사용하라!
* 이름이 길어도 된다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
* 함수 이름 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용하고 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.
* 이름을 지을 때 일관성이 있어야 한다.
* 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용한다.

### 6. 함수 인수
* 함수에서 이상적인 인수 개수는 0개(무항)이다. 적을 수록 좋다.
* 인수 4개 이상은 사용해서는 안 된다.
* 인수가 많을 경우, 테스트 관점에서 인수마다 유효한 값으로 모든 조합을 구성해 테스트하기가 부담스러워진다.

### 7. 플래그 인수
* 함수로 boolean 값을 넘기는 방법은 옳지 못 하다. 그 함수가 여러 가지 일을 한다는 것이기 때문이다.

###  8. 이항 함수
* 인수가 2개인 함수는 인수가 1개인 함수보다 이해하기 힘들다.
* 일반적으로 인수 2개를 취하는 직교 좌표계처럼, 이항 함수가 적절한 경우도 있다.
* 좌표계 2개 요소에는 자연적인 순서가 있다.
* 이항 함수의 단점은 자연적인 순서가 없을 경우에 인수 값을 잘 못 집어넣는 실수가 발생할 수 있다는 것이다.

### 9. 삼항 함수
* 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 이해하기 어렵다. 순서, 주춤, 무시로 야기되는 문제가 2배 이상 늘어난다.

### 10. 인수 객체
* 인수 2-3개가 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어보자.
<br/>
```Circle makeCircle(double x, double y, double radius)```
```Circle makeCircle(Point center, double radius)```

### 11. 인수 목록
* 때로는 String.fomat 메서드처럼 인수가 개수가 가변적인 함수도 필요하다.

### 12. 동사나 키워드
* 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
* 함수 이름에 키워드를 추가하는 형식도 있다. 즉, 함수 이름에 인수를 넣는 것이다.
* 예를 들어서, aeertEquals < assertExpectedEqualsActual(expected, actual)
* 이렇게 사용하면 인수 순서를 기억할 필요가 없어진다.

### 12. 부수 효과(Side effect)를 일으키지 마라!
* Side effect란? 함수 내의 실행으로 인해 함수 외부가 영향을 받는 것

### 13. 출력 인수
* 우리는 흔히 인수를 함수 입력으로 해석한다.
* 출력 인수로 사용하라고 설계한 변수가 바로 this
* 일반적으로 출력 인수는 피해야 한다.
* 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방법을 택한다.

### 14. 명령과 조회를 분리하라!
* 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중에 하나만 해야한다.

### 15. 오류 코드보다 예외를 사용하라!
### 16. 반복하지 마라!
