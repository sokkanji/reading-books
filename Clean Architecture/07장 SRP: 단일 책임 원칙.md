# SOLID 원칙

함수와 데이터 구조를 클래스로 배치하는 방법과 이 클래스들을 결합하는 방법을 설명한다.
이 원칙은 객체 지향 소프트웨어에서만 적용되는 것은 아니다.

SOLID 원칙의 목적은 아래와 같다.

- 변경에 유연하다
- 이해하기 쉽다
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

---

# SPR: 단일 책임 원칙

모든 모듈이 하나의 일만 해야한다는 의미가 아니다.

> 모듈 1개는 액터(변경을 요청하는 집단) 1개만 책임져야한다.

이 원칙을 이해하기 위해 이 원칙을 위반하는 징후들을 살펴보자.

## 징후 1: 우발적 중복

> 특정 함수를 사용하는 A, B가 있을 때, A가 함수를 수정하면 B에도 영향을 받는다.

서로 다른 액터가 의존하고 있는 한 코드를 각각 분리해야한다.

## 징후 2: 병합

> 서로 다른 목적으로 동일한 소스 파일을 변경하면 추후에 반드시 병합 해야한다.

서로 다른 액터를 뒷받침할 수 있도록 각 코드를 분리해야한다.

## 해결책

퍼사드 (Facade) 패턴

가장 중요한 메서드는 기존 클래스에 유지하고, 기존 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용한다.

## 결론

단일 책임 원칙은 메서드와 클래스 수준의 원칙이다.
컴포넌트 수준에서 공통 폐쇠 원칙이고,아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 기준이 축이 된다.
